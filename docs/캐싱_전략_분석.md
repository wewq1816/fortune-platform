# 캐싱 전략 분석 - 사주 8글자 시스템

작성일: 2025-01-02 23:30

---

## 🎯 핵심 질문

**"사주 8글자가 전부 다른데 캐싱이 의미가 있을까?"**

답: **네, 매우 중요합니다!**

---

## 📊 현실적인 시나리오

### **1. 실제 사용자 수 vs 가능한 조합**

| 항목 | 수치 | 설명 |
|------|------|------|
| **가능한 사주 조합** | 약 50만 개 | 60(년) × 60(월) × 60(일) × 12(시) = 2,592,000 |
| **실제 활성 사용자** | 1,000명 | 론칭 초기 |
| **하루 방문자** | 300명 | 재방문 포함 |
| **신규 사주** | 30개/일 | 10% 신규 유입 |
| **재방문 사주** | 270개/일 | 90% 기존 유저 |

### **2. 캐싱 없을 때 vs 있을 때**

#### ❌ **캐싱 없을 때**
```
하루 방문 300명 → 300번 API 호출
월간: 9,000번 호출
비용: 9,000 × $0.00025 = $2.25/월 (Haiku 입력 1K토큰 기준)
```

#### ✅ **캐싱 있을 때**
```
신규 30명 → 30번 API 호출 (캐시 생성)
재방문 270명 → 0번 API 호출 (캐시 재사용)
월간: 900번 호출
비용: 900 × $0.00025 = $0.23/월
절감: $2.02/월 (90% 절감)
```

---

## 🔑 **캐시 키 설계**

### **올바른 캐시 키**
```javascript
const cacheKey = `${날짜}_${사주8글자}_${버전}`;

예시:
"2025-01-02_경오기묘기묘갑자_v1"
"2025-01-03_경오기묘기묘갑자_v1"  // 다른 날이므로 새로 생성
"2025-01-02_을축병술임진경자_v1"  // 다른 사주이므로 새로 생성
```

### **캐시 유효기간**
```javascript
const cache = {
  key: "2025-01-02_경오기묘기묘갑자_v1",
  createdAt: "2025-01-02 00:00:00",
  expiresAt: "2025-01-03 00:00:00",  // 자정까지만 유효
  data: {
    총운: "...",
    애정운: "...",
    금전운: "...",
    // ...
  }
};
```

---

## 📈 **실제 효과 시뮬레이션**

### **시나리오 1: 론칭 초기 (DAU 300명)**

| 지표 | 캐싱 없음 | 캐싱 있음 | 절감률 |
|------|----------|----------|--------|
| 일간 API 호출 | 300회 | 30회 | 90% |
| 월간 API 호출 | 9,000회 | 900회 | 90% |
| 월간 비용 | $2.25 | $0.23 | 90% |

### **시나리오 2: 성장기 (DAU 3,000명)**

| 지표 | 캐싱 없음 | 캐싱 있음 | 절감률 |
|------|----------|----------|--------|
| 일간 API 호출 | 3,000회 | 300회 | 90% |
| 월간 API 호출 | 90,000회 | 9,000회 | 90% |
| 월간 비용 | $22.50 | $2.25 | 90% |

### **시나리오 3: 성숙기 (DAU 30,000명)**

| 지표 | 캐싱 없음 | 캐싱 있음 | 절감률 |
|------|----------|----------|--------|
| 일간 API 호출 | 30,000회 | 3,000회 | 90% |
| 월간 API 호출 | 900,000회 | 90,000회 | 90% |
| 월간 비용 | $225 | $22.50 | 90% |

---

## 💰 **비용 절감 효과**

### **연간 절감액**
```
론칭 초기: $24/년 절감
성장기: $243/년 절감
성숙기: $2,430/년 절감
```

### **왜 90% 절감이 가능한가?**
```
1. 재방문율이 높음 (55-65세 여성 타겟)
2. 아침에 한 번 보고, 하루 종일 재접속
3. 같은 날 = 같은 운세이므로 캐시 재사용
```

---

## 🎯 **캐싱 구현 전략**

### **1단계: 메모리 캐시 (개발 단계)**
```javascript
// 간단한 in-memory 캐시
const cache = new Map();

function getCachedFortune(cacheKey) {
  const cached = cache.get(cacheKey);
  if (cached && cached.expiresAt > Date.now()) {
    return cached.data;
  }
  return null;
}

function setCachedFortune(cacheKey, data) {
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);
  
  cache.set(cacheKey, {
    data: data,
    expiresAt: tomorrow.getTime()
  });
}
```

### **2단계: Redis 캐시 (프로덕션)**
```javascript
// Redis 캐시
const redis = require('redis');
const client = redis.createClient();

async function getCachedFortune(cacheKey) {
  const cached = await client.get(cacheKey);
  return cached ? JSON.parse(cached) : null;
}

async function setCachedFortune(cacheKey, data) {
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);
  
  const ttl = Math.floor((tomorrow.getTime() - Date.now()) / 1000);
  
  await client.setex(
    cacheKey, 
    ttl,  // 자정까지 남은 초
    JSON.stringify(data)
  );
}
```

---

## 🚀 **즉시 구현 가능한 간단 버전**

```javascript
// firebase/functions/daily-fortune.js
const cache = new Map();

exports.getDailyFortune = async (req, res) => {
  const { year, month, day, hour, isLunar } = req.body;
  
  // 1. 사주 8글자 계산
  const saju = calculateSaju({ year, month, day, hour, isLunar });
  
  // 2. 캐시 키 생성
  const today = new Date().toISOString().split('T')[0];
  const cacheKey = `${today}_${saju.sajuHanja}`;
  
  // 3. 캐시 확인
  let fortune = cache.get(cacheKey);
  
  if (fortune) {
    console.log('캐시 히트!', cacheKey);
    return res.json({ ...fortune, cached: true });
  }
  
  // 4. 캐시 없으면 AI 호출
  console.log('캐시 미스! API 호출...', cacheKey);
  fortune = await callClaudeAPI(saju);
  
  // 5. 캐시 저장
  cache.set(cacheKey, fortune);
  
  // 6. 자정에 자동 삭제
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(0, 0, 0, 0);
  const ttl = tomorrow.getTime() - Date.now();
  
  setTimeout(() => {
    cache.delete(cacheKey);
    console.log('캐시 만료:', cacheKey);
  }, ttl);
  
  return res.json({ ...fortune, cached: false });
};
```

---

## 📊 **캐시 히트율 예측**

### **일반적인 패턴**
```
아침 07:00-09:00: 신규 요청 多 (캐시 미스 60%)
점심 12:00-13:00: 재방문 多 (캐시 히트 80%)
저녁 18:00-20:00: 재방문 多 (캐시 히트 90%)
밤   21:00-23:00: 재방문 多 (캐시 히트 95%)

일평균 캐시 히트율: 약 85-90%
```

---

## 🎯 **결론**

### ✅ **캐싱이 꼭 필요한 이유**

1. **비용 절감**: 90% API 호출 감소
2. **응답 속도**: 캐시 히트 시 즉시 반환
3. **일관성**: 같은 날은 같은 운세 (사용자 경험 향상)
4. **서버 부하 감소**: API 호출 최소화

### ❌ **캐싱 없으면**
```
- 재방문 시마다 API 호출 (비용 10배)
- 같은 사주인데 내용이 조금씩 다름 (사용자 혼란)
- Claude API 속도에 의존 (느림)
```

---

## 📝 **다음 단계**

1. **즉시 구현**: 메모리 캐시 버전 (Map 사용)
2. **프로덕션**: Redis 캐시 도입
3. **모니터링**: 캐시 히트율 추적
4. **최적화**: TTL 조정, 프리로딩 등

**캐싱은 선택이 아닌 필수입니다!** 🎯
